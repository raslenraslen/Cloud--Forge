name: frontend CloudForge CI/CD Pipeline 


on:
  push:
    branches: ["main"]
    paths:
      - 'frontend/**'
      - '.github/workflows/Cloudforge-frontend.yml'
  pull_request:
    branches: ["main"]
    paths:
      - 'frontend/**'
      - '.github/workflows/Cloudforge-frontend.yml'

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    outputs:
      changes_detected: ${{ steps.check_files.outputs.changes_detected }}

    steps:
      - name: ðŸš› Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: ðŸ“¥ Download existing .done files
        uses: actions/download-artifact@v4
        with:
          name: frontend-done-files
          path: ./.github/done-files/
        continue-on-error: true

      - name: ðŸ§ Check for changes and done files
        id: check_files
        run: |
          cd ./frontend
          if [ -n "$(git diff --name-only HEAD~1 HEAD -- 'frontend/')" ]; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
          else
            echo "changes_detected=false" >> $GITHUB_OUTPUT
          fi
          cd ..
          echo "install_done=$(if [ -f ./.github/done-files/install.done ]; then echo 'true'; else echo 'false'; fi)" >> $GITHUB_OUTPUT
          echo "build_done=$(if [ -f ./.github/done-files/build.done ]; then echo 'true'; else echo 'false'; fi)" >> $GITHUB_OUTPUT
          echo "tests_done=$(if [ -f ./.github/done-files/tests.done ]; then echo 'true'; else echo 'false'; fi)" >> $GITHUB_OUTPUT

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: ðŸ—ï¸ Restore node_modules cache
        uses: actions/cache@v3
        with:
          path: frontend/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: ðŸ“¥ Install Dependencies
        if: ${{ steps.check_files.outputs.changes_detected == 'true' || steps.check_files.outputs.install_done == 'false' }}
        run: npm ci --legacy-peer-deps
        working-directory: ./frontend

      - name: ðŸ“Œ Mark install as done
        if: ${{ steps.check_files.outputs.changes_detected == 'true' || steps.check_files.outputs.install_done == 'false' }}
        run: |
          mkdir -p ./.github/done-files/
          echo "done" > ./.github/done-files/install.done

      - name: ðŸ› ï¸ Build Application
        if: ${{ steps.check_files.outputs.changes_detected == 'true' || steps.check_files.outputs.build_done == 'false' }}
        run: npm run build -- --configuration=production
        working-directory: ./frontend
        continue-on-error: true

      - name: ðŸ“Œ Mark build as done
        if: ${{ steps.check_files.outputs.changes_detected == 'true' || steps.check_files.outputs.build_done == 'false' }}
        run: |
          mkdir -p ./.github/done-files/
          echo "done" > ./.github/done-files/build.done

      - name: ðŸ§ª Run Unit Tests
        if: ${{ steps.check_files.outputs.changes_detected == 'true' || steps.check_files.outputs.tests_done == 'false' }}
        run: npm run test -- --no-watch --browsers=ChromeHeadlessCI
        working-directory: ./frontend
        continue-on-error: true

      - name: ðŸ“Œ Mark tests as done
        if: ${{ steps.check_files.outputs.changes_detected == 'true' || steps.check_files.outputs.tests_done == 'false' }}
        run: |
          mkdir -p ./.github/done-files/
          echo "done" > ./.github/done-files/tests.done

      - name: ðŸ“¤ Upload .done files
        uses: actions/upload-artifact@v4
        with:
          name: frontend-done-files
          path: ./.github/done-files/
          retention-days: 3

  security-check:
    runs-on: self-hosted
    needs: build_and_test
    steps:
      - name: ðŸšš Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download existing .done files
        uses: actions/download-artifact@v4
        with:
          name: frontend-done-filess
          path: ./.github/done-files/
        continue-on-error: true

      - name: ðŸ” Check if security scan needed
        id: check_scan
        run: |
          CHANGES_DETECTED="${{ needs.build_and_test.outputs.changes_detected }}"
          if [ -f ./.github/done-files/security.done ] && [ "$CHANGES_DETECTED" == "false" ]; then
            echo "skip_scan=true" >> $GITHUB_ENV
          else
            echo "skip_scan=false" >> $GITHUB_ENV
          fi

      - name: ðŸ” Run Trivy Scan
        run: trivy fs --security-checks vuln --format table -o fs-report.txt ./frontend/

      - name: ðŸ“Œ Mark security as done
        if: ${{ env.skip_scan != 'true' }}
        run: |
          mkdir -p ./.github/done-files/
          echo "done" > ./.github/done-files/security.done

      - name: ðŸ“¤ Upload updated .done files
        uses: actions/upload-artifact@v4
        with:
          name: frontend-done-filess
          path: ./.github/done-files/
          retention-days: 3

  SonarQube_Analysis:
    runs-on: self-hosted
    needs: security-check
    steps:
      - name: Checkout code with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download sonar.done if exists
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: sonar-done
          path: .

      - name: Check if sonar already done
        id: check_sonar
        run: |
          if [ -f sonar.done ]; then
            echo "skip=true" >> $GITHUB_ENV
          else
            echo "skip=false" >> $GITHUB_ENV
          fi

      - name: SonarQube Scan
        if: ${{ env.skip != 'true' }}
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        with:
          projectBaseDir: ./frontend
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: http://192.168.216.131:9000/

      - name: Download SonarQube JSON Report
        if: ${{ env.skip != 'true' }}
        run: |
          curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
            "http://192.168.216.131:9000/api/issues/search?componentKeys=CloudForge&resolved=false" \
            -o sonar-report.json

      - name: Upload SonarQube report
        if: ${{ env.skip != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sonar-report
          path: sonar-report.json

      - name: Mark sonar done
        if: ${{ env.skip != 'true' }}
        run: echo "Sonar done" > sonar.done

      - name: Upload sonar.done
        if: ${{ env.skip != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: sonar-done
          path: sonar.done

  build_docker_image_and_push:
    runs-on: self-hosted
    needs: SonarQube_Analysis
    steps:
      - uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: raslenmissaoui061
          password: Raslen12345

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: true
          tags: raslenmissaoui061/raslenmissaoui061/frontend-micro
          file: ./frontend/Dockerfile
  
  scan_image_with_trivy:
    runs-on: self-hosted 
  
    needs: build_docker_image_and_push 
    steps:
    - name: Scan Docker image for vulnerabilities with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        # On utilise l'output du job prÃ©cÃ©dent pour rÃ©cupÃ©rer le nom de l'image
        image-ref: ${{ needs.build_docker_image_and_push.outputs.image_tag }}
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os,library'
        severity: 'HIGH,CRITICAL'

  deploy-to-k8s-blue-green:
    runs-on: self-hosted
    needs: scan_image_with_trivy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
  
      

      - name: Get current active color
        id: get-color
        run: |
          ACTIVE_COLOR=$(kubectl get svc frontend-service -o jsonpath='{.spec.selector.color}')
          echo "Current color is $ACTIVE_COLOR"
          if [ "$ACTIVE_COLOR" = "blue" ]; then
            echo "TARGET_COLOR=green" >> $GITHUB_ENV
          else
            echo "TARGET_COLOR=blue" >> $GITHUB_ENV
          fi

      - name: Deploy new version to ${{ env.TARGET_COLOR }}
        run: |
          kubectl set image deployment/frontend-${{ env.TARGET_COLOR }} frontend=${{ secrets.DOCKER_USERNAME }}/cloudforge-frontend:latest

      - name: Wait for deployment to be ready
        run: |
          kubectl rollout status deployment/frontend-${{ env.TARGET_COLOR }}

      - name: Smoke test new deployment
        run: |
          kubectl run curl-test --rm -i --tty --image=curlimages/curl --restart=Never -- \
            curl http://frontend-${{ env.TARGET_COLOR }}:80 || exit 1

      - name: Switch service to ${{ env.TARGET_COLOR }}
        run: |
          kubectl patch svc frontend-service -p '{"spec": {"selector": {"app": "frontend", "color": "'${{ env.TARGET_COLOR }}'"}}}'
  
  
  
  
  
  notify_discord:
    runs-on: ubuntu-latest
    needs: [build_and_test, security-check, SonarQube_Analysis, build_docker_image_and_push]
    if: always()
    steps:
      - name: Get start time
        id: start
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Wait a bit to calculate duration
        run: sleep 5

      - name: Calculate and send Discord notification
        run: |
          end_time=$(date +%s)
          duration=$(( end_time - ${{ steps.start.outputs.start_time }} ))
          minutes=$((duration / 60))
          seconds=$((duration % 60))

          status="${{ needs.build_docker_image_and_push.result }}"
          if [ "$status" = "success" ]; then
            color="ðŸŸ¢"
          elif [ "$status" = "failure" ]; then
            color="ðŸ”´"
          else
            color="ðŸŸ¡"
          fi

          message="**$color frontend Angular CI/CD**\nðŸ”§ Workflow: \`${{ github.workflow }}\`\nðŸ’¼ Status: **$status**\nðŸ‘¤ Auteur: \`${{ github.actor }}\`\nðŸ•’ DurÃ©e: ${minutes}m ${seconds}s\nðŸ”— [Voir sur GitHub](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"

          curl -H "Content-Type: application/json" \
               -X POST \
               -d "{\"content\": \"$message\"}" \
               ${{ secrets.DISCORD_WEBHOOK }}
